# Choose-Your-Own Digital History Project, An Unessay

by Kelly Ferguson

If there is one thing that digital history has taught me this semester, besides a bunch of useful new tools, it is to be reflexive and transparent in your work. In the spirit of this, I wanted my unessay to acknowledge the process of doing this final project, making our game, and the thoughts and questions it brought up for me, and continues to bring up. I thought about a couple different options of how to format and present this reflection, thinking about some kind of audio presentation, or maybe a model of the words that I used to discuss it. In the end, I decided that I didn't want to choose a format simply for the sake of choosing a different format. For me, writing is how I communicate best; iallows me to organize my thoughts and be clear about what I am saying. I still wanted my format to reflect the questioning I've done through the process of this project, and so I decided to do this unessay Q&A-style. I wanted to work through the questions I had, and continued to have, in a way that was transparent, rather than only acknowledging the conclusions I came to.

A note about some of these questions. While some of them are just things that I have thought about in working on this project, some are questions that were posed to me and/or my group about the project that made me think more about the process. Also, these are the main questions that I have thought about, but not all. Many of questions not included here are at least partially answered in the questions included, and so I cut them for sake of length and to avoid too much repetition.

**The first question I think should be asked about any digital history project is why? What is the point of this project? What did you set out to accomplish?**

This project for me started out in an interesting way. I was originally asked by Sara and Brad if I wanted to work on the final project as a group. It seemed like a good fit. We all were around the same level in terms of computer skills going into the course, and we all suffered through the sometimes vague instructions in the Programming Historian[^1] for Windows users. At first, that was the thing we wanted our game to address, the hidden gotchas and tricks that Windows users needed to know about in order to do the Programming Historian tutorials. This original idea started to change as we began talking about setting it up as a Twine. Our original idea of going through the Programming Historian tutorials and pointing out the gotchas and helpful hints as we went along would have made for a pretty boring game. It would have been very linear, which is kind of the opposite of what makes Twine useful. To prevent our project from being too linear, we started to think about it in a different way. We started to think about what someone who wanted to learn about digital history tools and use them for their research would want and need to know. We also started to think about how the "need to know information", based on the person's skill level, may interconnect with what they wanted to know.

This thought process is what led to the design of our final Twine game. We decided that the best way for us to approach this project was to think about the variety of starting points people may bring to this game. Some may start out with the knowledge that we had before the beginning of this class (which is to say, very little). These people would need to learn about a couple of basic tools before they could comfortably jump into starting their own digital history project. Others may be closer to the knowledge base that we currently have at the end of this course. While this definitely isn't an expert-level amount of knowledge, these people may feel comfortable going straight into starting a digital history project. We kept the ability to go back to the relevant basic skills throughout the project section because we all understood the feeling of technically knowing the basics, but sometimes needing a refresher when it comes time to apply them. We also wanted our project to reflect the connected and never-ending process of doing digital history. There are always new tools to learn about and the past tools, particularly the basics, never stop being relevant in being able to use more complex programs. Because of this, we made everything as interconnected as possible.

**Why is Twine a good tool for what you wanted to accomplish with this project?**

This question is one that has come up repeatedly through this course. The idea being that it is important to check in and reflect on whether the tool you are using is the best for what you want to accomplish with your project. In some ways the best tool will be the one that you find the easiest to work with, but it is important to think about what the design of the tool is and what results it is going to provide. At the beginning of this project, I don't think what we wanted to do was the best use of Twine. As I've already discussed, our original product would have been very linear in its layout, which is not the intent of tool like Twine. Twine allows you to make connections and to allow the user to choose their own path, and our original concept didn't really lend itself to that. Interestingly, using Twine was never really a question that we, as a group, asked ourselves. It was always the assumption that we would use Twine to build our project, I think because that was the suggested tool way back at the beginning of the course. Rather than following the advice that we had been discussing throughout the term, to pick the tool that is the best for what you want to do, we ended up doing almost the opposite. Our choice of tool, which we were set in using, ended up shaping our project. Rather than change the tool to fit our original idea, we changed our original idea to fit and take advantage of the tool that we wanted to use. I don't necessarily think that this was a bad way to go about our project, in many ways it made our project a lot more useful and interesting. It is important, though, to acknowledge the way in which our decision to stick with Twine changed our project throughout this process.

In terms of the project that we ended up building, I really do think that Twine was the a good tool to have used, if not the best. We decided to create a game that allowed people to learn the things the way they wanted to, without sifting through the information that they didn't care about. A kind of choose-your-own adventure of learning about digital history. At times, when going through the Programming Historian tutorials, we found there was more discussion than we needed or wanted about the tool itself, or that there was information missing in terms of other tools that would have been useful to read about. We wanted the people who go through our game to be able to choose the path that made the most sense to them, including extra information if they needed it, but allowing them to skip past it if they didn't. This flexibility is what we thought to be one of the more useful elements of Twine; the ability to talk about a bunch of different subjects in a connected way, but not forcing anyone to follow a specific path that may or may not be useful.

**How did the Programming Historian influence this project?**

The most obvious answer to this question is that the Programming Historian tutorials were what formed the basis of our knowledge surrounding these tools. These tutorials formed the foundation of all of the skills were were trying to discuss in the project. In this sense, the way in which we explain these tools, and personally understand them, are very much influenced by the language and the format of the Programming Historian.

The Programming Historian tutorials also influenced us by bringing up the gaps and the issues that we hoped our game would address. It was our experience, and at times frustration, with the Programming Historian that pushed our project in the direction that it ended up going. From the beginning we want to get rid of some of the frustrating aspects of the Programming Historian. At first this was as simple as bringing Windows users to the forefront and going through the tips and tricks needed to get these tutorials to work on PCs. As the project developed, we started thinking about the way in which Programming Historian tutorials sometimes assumed knowledge, rather than fully explaining tools and terms. We decided to make two sides to our project, one for basic skills and the other for projects, and link between the two whenever possible so that people could customize their experience based on their level of skill going in. We wanted to get rid of this assumed knowledge issue that we experienced with the tutorial process. Whether or not we were completely successful in this endeavour is up for debate, but the way we see and approach learning digital history is inextricably linked to our own learning process with the Programming Historian.

**What is the purpose of a digital history tutorial?**

This question is one that I have thought a lot about during the process of making this game. We didn't want our game to just be the Programming Historian tutorials in a different format, but wanted it to have a purpose that set it a part as its own learning tool. The question quickly seemed to become focused on the tension between the explanation of the tool itself, versus the explanation of its implications. Which should be the focus of our discussions? It was during this process that we went through the Programming Historian tutorial on the program AntConc [^2], written by  Heather Froehlich. Froehlich's tutorial was really interesting to me because it took the tool, AntConc, and used it almost as a jumping off point to discuss the implications of digital history more generally. I think in part because it is a fairly straightforward tool, Froelich focused less on explaining the tool itself and more on what the choices you make when using the tool does to your research results. This really struck a chord with me. Although we had discussed the implications of digital tools in class, and although we had been discussing the need to be critical and reflective about these tools all semester, seeing this discussion as the focus in a tutorial opened up my views of what our project could be. After going through that tutorial, I became much more interested in making sure these implications were discussed in our project, and the question became focused on finding that balance.

I'm still not sure what the perfect balance between skills and reflections should be in a digital history tutorial. Our game almost avoided making a concrete statement on the topic by allowing people to choose what discussions they wanted to read about. In my section of the project in particular, I made learning about the implications of a particular tool a specific option, allowing people to skip past it if they weren't interested. I did this because the whole point of our Twine was allowing people to choose what information they wanted and allowing people to make their own choice in what they wanted to learn. If someone doesn't care about the implications of the tools they're using, I doubt that my little blurb on the topic would change their mind regardless, and they are free to decide to skip past it. In allowing this choice, we allow the people playing this game to determine what the perfect balance is for them. I'm sure that giving this option has its own implications in the discussion (and is probably making a statement whether I want it to or not), but as someone who is still in the process of learning about digital history herself, it seems disingenuous to put down a hard rule on how much discussion of the implications is the right amount for everyone in learning about digital history.

**What are some of limitations or issues that came up in this project?**

After all of the tutorials that I have gone through this year, and after the process of trying to build a project that would be able to teach others how to do digital history, I have come to the conclusion that it is probably impossible to design the perfect digital history tutorial. It's easy to see what you would personally want in a tutorial, but everyone has different goals, everyone is starting at slightly different skill level and everyone learns differently, making it hard to meet everyone's needs. We tried our best to acknowledge these differences as best as we could in our project and I think we do a pretty good job at making the game valuable to a variety of people, but I'm sure there will still be issues.

One decision that we had to make was the level of detail we wanted to put into each tool we discussed. We had to decide how much step by step instructions we would give, and how many tools we would discuss. In attempts to be useful to a wide variety of skill level, while also trying to keep the game from getting too long, we settled on basic introductions to tools, with linked resources for those who wanted more detail. We would tell you the basic what, when, why, and how of a tool, but we would also provide links to Programming Historian tutorials for those who wanted more detail, particularly in terms of the "how".  I think this does limit the project in some ways in that it isn't necessarily a standalone learning tool; someone coming in with no knowledge at all would probably not be able to go through the entire game and know how to perfectly use all of the tools without clicking those links.  I don't think that we ever thought that this would be a one hundred percent standalone tool. To us, this project was designed as an introduction for those who were intimidated by digital history to get a comfortable grasp on some tools and topics before they try to do a research project on their own. Specifically, a tool to make their transition into a digital history project a little easier.

Another possible limitation that our project may have is the assumptions of knowledge we make in the game. One of things that was frustrating in terms of the Programming Historian tutorials was that they would often assume knowledge without explanation. We wanted our game to fix that aspect of the tutorial process by providing access to the basics at all times. It's really hard, though, to think past your own base knowledge to remember what you wouldn't have known before the start of the course. Now that we have a little more knowledge surrounding digital history, we have to try to constantly reflect on the assumptions we are making of what people do or do not know. I hope that we were relatively successful in this, but I'm sure we weren't perfect.

P.S. After watching Brad's twitter conversation surrounding our project, it seems that some of these limitations are in fact being noticed by those playing the game. Brad's received feedback suggesting that our game is too broad to be helpful with specific projects and that some of our terminology is not as clearly explained as it could be. I'm hoping we can go in and fix the terminology issues. Also, though I stand by the idea of our project as a first step, rather than a standalone teaching tool, the issue of broadness is something that I think we could have been more upfront about. We could have made more of an emphasis perhaps on the fact that it is not intended to teach everything in detail, but is a modest introduction to the material. It's great to see though, through Brad's project, how people without any background in digital history are experiencing our project, so that we can see where the holes really are.

**What would you have done differently?**

In the development of the project itself, there were a lot of things that occurred to us as we progressed that could have been different, some of which we are working on fixing for the final project, others are more lessons for the future. One of the things that came up as we were going through the games in our final class was something mentioned by Sara McGillivray, that our game was a little too long. It is a long game. I think that in our desire to be clear and helpful to people on a variety of topics and a variety of projects, we built a game that was a little long for someone who wanted to go through the whole thing, start to finish. At the same time, though, to me this project isn't necessarily designed for everyone to go through from start to finish, but is designed so that people can start wherever they want based on what they want to learn. In this case, I think we needed a decent number of options to be able help a larger variety of people. I think there is a happy medium that we could have maybe tightened it up a little bit to make it more digestable for the person who wants to go through from start to finish, while still being helpful for those who want to pick and choose.

Another thing that I think we would probably (hopefully) do differently if we were to do this project again doesn't really involve the final project itself, but focuses on the way we worked on the different pages before putting them into the Twine. At the beginning of the project, we weren't really sure how it was going to work, three people working on one Twine, so we decided to write "scripts" (like a play, rather than computer scripts) and organize them in Dropbox folders that represented the links of the Twine. Also, and I'm not proud of this, we wrote these scripts in Microsoft Word. This choice would become particularly ironic when Brad was writing the section on future-proofing and why not to use Word, although it was kind of ridiculous for all of us after spending the whole semester discussing the benefits of text files and markdown. It's not as though we didn't believe in the things we were learning and saying, I had been writing my notes all year in a plain text editor and have been saving everything for this course through GitHub, including this reflection. I think that the reason for reverting back to Word was a partially due to habit and partially due to comfort. When doing something casual like taking notes or writing a blog post, it was easy to just use a text editor rather than Word. I think when it came time to work on a major project though, all of our brains immediately took us back to something that was familiar. There was habit of writing a project = open up Word. There wasn't even a discussion in our group of why we would use Word until near the end, it was just the knee-jerk reaction we all had in terms of writing up a major project. Although it didn't have any major impact one way or another in terms of doing the project, I think that it would have felt more genuine if we had been practicing what we were preaching in our project.

**How would you change your methods and/or approach in terms of this project?**

Again, particularly in terms of using Word to write our project, I think that just going through this whole class will change our methods and approach should we do a project like this again. Once we realized the ridiculousness of writing about future-proofing and markdown in a Word document, I think it was an eye-opening experience for everyone. We discuss in class a lot this idea that learning digital history is a process, one that Dr. Graham, for example, has been working at for years. In comparison we have only been working on digital history for twelve weeks, which really isn't very long. At the same time, I think everyone, including myself, have come pretty far in that time. Halfway through the semester, it never crossed my group's mind to be critical of why we were using Word, whereas now I don't think we would have used Word if we were restarting this project.

I think this idea of the process of digital history can be applied to any tool. If we were to restart our Twine it would probably look different because in the process of making the Twine we had to learn about Twine. We have much more knowledge about the options in Twine now, then we did when we started building it. Even looking at other people's Twines have given us new ideas that we would have probably applied if we had realized the options. Laurel's and Emily's Twine, for example, had a lot of interactive images and sounds that I didn't even think of while we were working on our project. If we were to do this project again, I'm sure that more elements like that would have been included.  I think that this is kind of the point of the process of digital history though. You learn about a tool by working through it, but you also learn about it by seeing how others apply it. The more experience you have with a tool, the more you can do with it. So, while I do think that there are a few things we would change about our project, if we knew then what we know now, I think that part of this project is the snapshot it provides of the way we used Twine, based on what we knew at the time.


**What about the visualization of the project and the performance in terms of presentation?**

The presentation of the game is definitely something that we thought about throughout the process of working on this project. Although we didn't have very much experience with the different options in the bells and whistles of Twine, we wanted to highlight the process of working on this project as a group. We all had our own topics that we were discussing, and we all have our own writing styles that were going to be represented in the project, and we wanted to make that clear. The main thing that we knew we wanted to do in terms of the visual presentation of the Twine is to have our own distinct voices, and we decided to do this with different coloured fonts. I was a little nervous at first about doing this because the process of changing the font colours involved CSS, which I had never heard of before, let alone used. Thankfully, Sara McGillivray had done a little with CSS in the past and showed Brad and I how to change font colours. The font colours, I think, helped to highlight the collaborative nature of the project and made the differences in voice across different sections less jarring and made it make more sense. Looking at some of the other projects, the seemingly unlimited options surrounding audio or interactive movements available with Twine is something that I would definitely look into more in the future, now that I realize that they exist, however I think that the presentation of our Twine shows what we wanted it to. It's clean and relatively simple, but it also shows the collaborative nature of the project.

**What has working on this project taught you about digital history?**

There was very much a back and forth in terms of what this project taught me about digital history and how learning digital history influenced and shaped this project.  In many ways, this project is a result of the things we have been discussing in class all semester. The idea of being reflective about the tools that we use in particular moved this project in an entirely different direction than how it started. Instead of focusing on the tips and tricks needed to do Programming Historian tutorials as a Windows user, we began to think about the project in terms of what kind of discussion needs to happen when talking about a digital history tool. While part of that is clearly the "how-to" part of teaching people about the tool, this course has taught me that an understanding of the "why", including the implications, is just as important. Also, simply working through tutorials for class taught me that, when trying to teach people about digital history, there are so many different things to keep in mind. You need to think of what kind of knowledge you audience is starting out with and what kind of assumptions you're making in terms of explanations. You also need to think about how much time you are going to spend discussing the skill itself versus being reflective about the tool. While doing all of this you need to think about why someone is coming to learn this skill and how to connect your tutorial to possible projects people may have. All of these aspects of teaching digital history are impossible to balance perfectly, and so, while we had to take them all into consideration for our project, we also had to realize and acknowledge the possible limitations we would have in the final product.

In terms of what this project taught me about digital history, the biggest thing was that it really highlighted the process of doing digital history. At the beginning of this course, I mainly thought about digital history in terms of the skills and tools I would be learning each week. These tools would then be a part of my knowledge base and I would be able to use them going forward. Doing this project really hit home the idea that digital history is more complicated than that. Besides the implications of these tools and skills, just the act of incorporating the things I've learned into life outside of class is more complicated than I would have originally thought. I'd rather not continually bring up the fact that we used Word to write this project, but I think that aspect was what really hit home this idea of process. We reverted back to what we were comfortable doing as soon as an actual project came along and it made me think about how long it will probably take before I stop using Word altogether. I've had the tools to do so since we learned about Markdown and Pandoc at the beginning of the term, but it is something I know I will struggle to stop doing. To me, that is what digital history is. It's slowly learning tools and learning how to do things in a different way while struggling against the way that you are comfortable doing things. Ideally, you keep pushing through the temptation to stick with what you know and these lessons of digital history eventually become the new comfortable way to do things. In this regard, digital history really isn't that much different of learning a new way to do anything. It's always a process.

**Did we do what we set out to do?**

I think that the finished project, for the most part, did what we wanted it to do. We wanted to create a choose-your-own adventure style way of learning about digital history tools. We wanted people to go through and pick the things they were interested in learning, and ignore the stuff they didn't need or didn't want to know about. We also set out with this project wanting to be reflective about the tools that we were discussing, and I think we did that as well. We discussed the implications of digital history throughout and although we let people skip by those parts if they wanted, I don't think that lessens their importance. There will always be people who will see and use these tools and not think critically about what they mean for their research. Hopefully, even if they skipped by the discussions of the implications, seeing that those sections exist will give them pause for thought while using these tools. Also, even though no learning tool can be everything for everybody, I think that we succeeded in building a resource for people to at least begin to learn about the tools available for their projects, even if the project cannot always be the standalone method of learning. Like pretty much all tutorials, it isn't perfect, but I think that our tool does achieve what we, or at least what I, was expecting it to.


[^1]: "About the Programming Historian," The Programming Historian, last modified March 29, 2016, http://programminghistorian.org/

[^2]: "Corpus Analysis with AntConc," The Programming Historian, last modified March 29, 2016, http://programminghistorian.org/lessons/corpus-analysis-with-antconc
